{
  "version": 0.2,
  "phases": {
    "pre_build": {
      "commands": [
        "echo Logging in to Amazon ECR...",
        "aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com",
        "echo Logging in to Docker Hub...",
        "echo \"$DOCKERHUB_PASS\" | docker login --username \"$DOCKERHUB_USER\" --password-stdin"
      ]
    },
    "build": {
      "commands": [
        "echo Downloading latest Prisma Cloud twistcli...",
        "curl -k -u \"$PRISMA_USER:$PRISMA_PASS\" \"$PRISMA_CONSOLE_URL/api/v1/util/twistcli\" --output twistcli",
        "chmod +x ./twistcli",
        "echo Creating temp data folder for twistcli",
        "mkdir -p ./twistcli_data",
        "./twistcli app-embedded embed --data-folder ./twistcli_data --address $PRISMA_CONSOLE_URL --user $PRISMA_USER --password $PRISMA_PASS --app-id my-secure-app Dockerfile",
        "echo Unzipping the embedded defender package...",
        "unzip app_embedded_embed_my-secure-app.zip -d ./embedded-build",
        "echo Copying application files to the build directory...",
        "cp index.html ./embedded-build/",
        "echo Removing conflicting ENTRYPOINT from the generated Dockerfile...",
        "sed -i '/ENTRYPOINT \\[\"nginx\", \"-g\", \"daemon off;\"\\]/d' ./embedded-build/Dockerfile",
        
        "echo '--- Displaying final Dockerfile for debugging ---'",
        "cat ./embedded-build/Dockerfile",
        "echo '-------------------------------------------------'",

        "echo Building the secured Docker image from the modified Dockerfile...",
        "docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG ./embedded-build",
        "docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG",
        "echo Pushing the image to ECR...",
        "docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG"
      ]
    },
    "post_build": {
      "commands": [
        "echo Configuring kubectl with IAM role for token creation...",
        "aws eks --region $AWS_REGION update-kubeconfig --name $EKS_CLUSTER_NAME",
        "echo Getting Service Account token...",
        "K8S_TOKEN=$(kubectl create token codebuild-deployer -n kube-system --duration 600s)",
        "echo Generating new kubeconfig from Service Account token...",
        "CLUSTER_ENDPOINT=$(aws eks describe-cluster --name ${EKS_CLUSTER_NAME} --query 'cluster.endpoint' --output text)",
        "CLUSTER_CA=$(aws eks describe-cluster --name ${EKS_CLUSTER_NAME} --query 'cluster.certificateAuthority.data' --output text)",
        "echo \"apiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data: ${CLUSTER_CA}\n    server: ${CLUSTER_ENDPOINT}\n  name: eks-cluster\ncontexts:\n- context:\n    cluster: eks-cluster\n    user: codebuild-sa\n  name: sa-context\ncurrent-context: sa-context\nkind: Config\npreferences: {}\nusers:\n- name: codebuild-sa\n  user:\n    token: ${K8S_TOKEN}\" > /tmp/kubeconfig.yaml",
        "export KUBECONFIG=/tmp/kubeconfig.yaml",
        "echo Starting deployment to EKS Fargate...",
        "IMAGE_URL=\"$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG\"",
        "sed -i \"s|image:.*|image: $IMAGE_URL|g\" k8s/deployment.yaml",
        "echo Applying Kubernetes manifests...",
        "kubectl apply -f k8s/deployment.yaml",
        "kubectl apply -f k8s/service.yaml",
        "echo Deployment complete! ðŸŽ‰"
      ]
    }
  }
}